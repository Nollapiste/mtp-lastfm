# Copyright 2009 Daniel Woodhouse
#
#This file is part of mtp-lastfm.
#
#mtp-lastfm is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#mtp-lastfm is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with mtp-lastfm.  If not, see http://www.gnu.org/licenses/
import md5
import urllib2
import urllib
import webbrowser
import httplib
import xml.etree.ElementTree as ET
from httprequest import HttpRequest

class LastfmWebService(object):
    
    def __init__(self):
        self.api_key = "2d21a4ab6f049a413eb27dbf9af10579"
        self.api_2 = "6146d36f59da8720cd5f3dd2c8422da0"
        self.url = "http://ws.audioscrobbler.com/2.0/"
    
    def request_session_token(self):
        """returns a token which is used authenticate mtp-lastfm with the users account"""
        data = {"api_key" : self.api_key, "method" : "auth.gettoken"}
        data['api_sig'] = self.create_api_sig(data)
        encoded_data = urllib.urlencode(data)
        url = self.url + "?" + encoded_data
        conn = urllib2.urlopen(url)
        return self.parse_xml(conn, "token")

    def parse_xml(self, conn, tag):
        """Searches an XML document for a tag and returns its value"""
        tree = ET.parse(conn)
        iter = tree.getiterator()
        for child in iter:
            if child.tag == tag:
                token = child.text
                break
        try:
            return token
        except:
            return False
        
    def create_api_sig(self, dict):
        """dict is a dictionary of param_name : value sorted into the correct order"""
        data = ""
        items = dict.items()
        items.sort()
        for i in items:
            for j in i:
                data += j

        data += self.api_2
        api_sig = md5.new(data.encode('UTF-8')).hexdigest()
        return api_sig
    
    
    def request_authorisation(self, token):
        """Opens a browser to request users authentication"""
        encoded_values = urllib.urlencode({
            "api_key" : self.api_key,
            "token" : token
        })
        webbrowser.open("http://www.last.fm/api/auth/?" + encoded_values)
        
        
    def create_web_service_session(self, token):
        """The final step, this creates a token with infinite lifespan store in db"""
        data = {
            "api_key" : self.api_key,
            "method" : "auth.getsession",
            "token" : token }
        data['api_sig'] = self.create_api_sig(data)
        encode_values = urllib.urlencode(data)
        url = self.url + "?" + encode_values
        try:
            conn = urllib2.urlopen(url)
            self.key = self.parse_xml(conn, "key")
            return True, self.key
        except urllib2.HTTPError:
            return False, "A problem occurred during authentication"
    
    
    def love_track(self, artist, track, sk):
        #Params
        #track (Required) : A track name (utf8 encoded)
        #artist (Required) : An artist name (utf8 encoded)
        #api_key (Required) : A Last.fm API key.
        #api_sig (Required) : A Last.fm method signature.
        #sk (Required) : A session key generated by authenticating a user.
        post_values = {
            "track" : track,
            "artist" : artist,
            "api_key" : self.api_key,
            "method" : "track.love",
            "sk" : sk}
        post_values['api_sig'] = self.create_api_sig(post_values)
        post_values = urllib.urlencode(post_values)

        req = urllib2.Request(url=self.url, data=post_values)
        try:
            url_handle = urllib2.urlopen(req)
            response = url_handle.readlines()[1]
            l = response.find('"') + 1
            r = response.rfind('"')
            response = response[l:r]
            if response == "ok":   
                return True
        except urllib2.URLError:
            response = """Connection Refused due to URLError 
                       (Incorrect session_key, track or artist)
                       Artist: %s
                       Track: %s
                       Session Key: %s""" % (artist, track, sk)
        except httplib.BadStatusLine:
            response = 'Bad Status Line'
        self.parent.write_info(response)
        return False

    
